addtwo <- function(x, y) {
x+y
}
addtwo(3,5)
above <- function(x,n) {
use <- x>n
x[use]
}
x <- 1:20
n <- 5
above(x,n)
above(x,19)
above(x)
above(x,n)
above <- function(x,n) {
use <- x>n
x[use]
}
above <- function(x,n = 10) {
use <- x>n
x[use]
}
above(x)
columnmean <- function(y) {
nc <- ncol(y)
means <-numeric(nc)
for(1 in 1:nc)}
means[i] <- mean(y[,i])
}
means
}
columnmean <- function(y) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) }
means[i] <- mean(y[,i])
}
means
}
columnmean <- function(y) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(y[,i])
}
means
}
cube <- function(x,n) {
x^3
}
cube(3)
x <- 1:10
if(x > 5) {
x <- 0
}
x <- 1:10
if(x > 9) {
x <- 0
}
x <- 1:10
if(x == 9) {
x <- 0
}
x <- 1:10
if(x == 9) {
x <- 0
}
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
f(3)
z <- 10
f(3)
f <- function(x) {
g <- function(y) {
y + z
}
z <- 10
x + g(x)
}
f(3)
x <- 5
y <- if(x < 3) {
NA
} else {
10
}
y
x <- 4L
x
class(x)
h <- function(x, y = NULL, d = 3L) {
z <- cbind(x, d)
if(!is.null(y))
z <- z + y
else
z <- z + f
g <- x + y / z
if(d == 3L)
return(g)
g <- g + 10
g
}
h(3)
h(3,2)
z <- cbind(3, 3L)
z
environment()
h <- function(x, y = NULL, d = 3L) {
z <- cbind(x, d)
if(!is.null(y))
z <- z + y
else
z <- z + f
g <- x + y / z
if(d == 3L)
return(g)
g <- g + 10
g
}
f(2)
h(2
h(2)
h(2)
h <- function(x, y = NULL, d = 3L) {
z <- cbind(x, d)
if(!is.null(y))
z <- z + y
else
z <- z + f
g <- x + y / z
return(g)
g <- g + 10
g
}
h(2)
x<-matrix(1:4,2,2)
x
solve(x)
getwd()
getwd()
setwd("~/R/Week3")
dir
ls
setwd("C:\Users\kasiulkah\datasciencecoursera\ProgrammingAssignment2")
getwd()
setwd("C:/Users/kasiulkah/datasciencecoursera/ProgrammingAssignment2")
getwd()
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<-y
m <<- NULL
}
get <- function() x
setInverse <- function(solve) m <<- solve
getInverse <- function() m
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getInverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setInverse(m)
m
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getInverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setInverse(m)
m
}
x <- matrix(1:4,2,2)
cacheSolve(x)
traceback()
debug(cacheSolve)
cacheSolve(x)
Q
Q
print(Q)
Q
print(Q)
Q
x
cacheSolve(makeCacheMatrix)
q
q
